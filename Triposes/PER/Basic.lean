import Triposes.Language.Basic
import Triposes.Language.Properties

import Mathlib.CategoryTheory.Generator

open Language
open CategoryTheory
open MonoidalCategory
open ChosenFiniteProducts

universe u v
variable {ùíû : Type u} [Category.{v, u} ùíû] [fp : ChosenFiniteProducts ùíû] [ccc : CartesianClosed ùíû]

/- Fix a tripos -/
variable {P : ùíû·µí·µñ ‚•§ HeytAlg} [T : Tripos P]

section PERdef
  syntax:90 fpterm "=[" term "]" fpterm:70 : fpformula
  local macro_rules
  | `($Œì:fpcontext ‚ä¢‚Çï $x:fpterm =[ $œÅ:term ] $y:fpterm) => `($Œì:fpcontext ‚ä¢‚Çï ‚ü™.Œπ $œÅ | ‚ü®$x, $y‚ü©‚ü´) --  =[]

  -- variable {X : ùíû} {rel : P‚ÇÄ (P := P) (X ‚äó X)}
  -- #check a : X, b : X        ‚ä¢ (a =[rel] b) ‚áí (b =[rel] a)
  -- #check a : X, b : X        ‚ä¢ a =[rel] b ‚áí b =[rel] a

  class PER (X : ùíû) where
    rel   : P‚ÇÄ (P := P) (X ‚äó X)
    sym   : a : X, b : X        ‚ä¢ a =[rel] b ‚áí b =[rel] a
    trans : a : X, b : X, c : X ‚ä¢ a =[rel] b ‚äì b =[rel] c ‚áí a =[rel] c
end PERdef

namespace Language
  syntax:90 fpterm "=" fpterm:70 : fpformula
  macro_rules
  | `($Œì:fpcontext ‚ä¢‚Çï $x:fpterm = $y:fpterm) =>
    `($Œì:fpcontext ‚ä¢‚Çï ‚ü™.Œπ (PER.rel (X := _)) | ‚ü®$x, $y‚ü© ‚ü´)
  | `($Œì:fpcontext ‚ä¢‚Çï $x:fpterm =[ $œÅ:term ] $y:fpterm) =>
    `($Œì:fpcontext ‚ä¢‚Çï ‚ü™.Œπ (PER.rel (X := $œÅ)) | ‚ü®$x, $y‚ü© ‚ü´)
end Language

section PERHomDef
  syntax:1025 term:1024 "‚∏®" fpterm "‚∏© =" fpterm : fpformula
  local macro_rules
  | `($Œì:fpcontext ‚ä¢‚Çï $map:term ‚∏® $x:fpterm ‚∏© = $y:fpterm) => `($Œì:fpcontext ‚ä¢‚Çï ‚ü™.Œπ $map | ‚ü®$x, $y‚ü©‚ü´)

  class PERHom {X Y : ùíû} (œÅX : PER (P := P) X) (œÅY : PER (P := P) Y) where
    hom : P‚ÇÄ (P := P) (X ‚äó Y)
    congrDom : x : X, x' : X, y : Y ‚ä¢ x = x' ‚äì hom‚∏®x'‚∏© = y ‚áí hom‚∏®x‚∏© = y
    congrCod : x : X, y : Y, y' : Y ‚ä¢ hom‚∏®x‚∏© = y ‚äì y = y' ‚áí hom‚∏®x‚∏© = y'
    unique   : x : X, y : Y, y' : Y ‚ä¢ hom‚∏®x‚∏© = y ‚äì hom‚∏®x‚∏© = y' ‚áí y = y'
    total    : x : X                ‚ä¢ x = x ‚áî ‚àÉ y : Y , hom‚∏®x‚∏© = y

end PERHomDef

namespace Language
  macro_rules
  | `($Œì:fpcontext ‚ä¢‚Çï $hom:term ‚∏® $x:fpterm ‚∏© = $y:fpterm) =>
    `($Œì:fpcontext ‚ä¢‚Çï ‚ü™.Œπ (T := T) (PERHom.hom (self := $hom)) | ‚ü®$x, $y‚ü©‚ü´)
end Language

namespace PERHom
  variable {X Y Z : ùíû} {œÅX : PER (P := P) X} {œÅY : PER (P := P) Y} {œÅZ : PER (P := P) Z}

  @[reducible]
  def congrDomTerm  (f : PERHom œÅX œÅY) := x : X, x' : X, y : Y ‚ä¢‚Çï x = x' ‚äì f‚∏®x'‚∏© = y ‚áí f‚∏®x‚∏© = y
  @[reducible]
  def congrCodTerm  (f : PERHom œÅX œÅY) := x : X, y : Y, y' : Y ‚ä¢‚Çï f‚∏®x‚∏© = y ‚äì y = y' ‚áí f‚∏®x‚∏© = y'
  @[reducible]
  def uniqueTerm    (f : PERHom œÅX œÅY) := x : X, y : Y, y' : Y ‚ä¢‚Çï f‚∏®x‚∏© = y ‚äì f‚∏®x‚∏© = y' ‚áí y = y'
  @[reducible]
  def totalTerm     (f : PERHom œÅX œÅY) := x : X ‚ä¢‚Çï x = x ‚áî ‚àÉ y : Y , f‚∏®x‚∏© = y
  @[reducible]
  def totalTerm_mp  (f : PERHom œÅX œÅY) := x : X ‚ä¢‚Çï x = x ‚áí ‚àÉ y : Y , f‚∏®x‚∏© = y
  @[reducible]
  def totalTerm_mpr (f : PERHom œÅX œÅY) := x : X ‚ä¢‚Çï ‚àÉ y : Y , f‚∏®x‚∏© = y ‚áí x = x

  @[reducible]
  def total_mp      (f : PERHom œÅX œÅY) : x : X ‚ä¢ x = x ‚áí ‚àÉ y : Y , f‚∏®x‚∏© = y := by
    have ‚ü®total_mp, _‚ü© := conj_eq_top_iff.mp f.total
    exact total_mp
  @[reducible]
  def total_mpr     (f : PERHom œÅX œÅY) : x : X ‚ä¢ (‚àÉ y : Y , f‚∏®x‚∏© = y) ‚áí x = x := by
    have ‚ü®_, total_mpr‚ü© := conj_eq_top_iff.mp f.total
    exact total_mpr
end PERHom


-- variable {X Y Z : ùíû} {œÅX : PER (P := P) X} {œÅY : PER (P := P) Y} {œÅZ : PER (P := P) Z} (g : PERHom œÅY œÅZ) (f : PERHom œÅX œÅY) (h : PERHom œÅX œÅZ)
-- #check f.hom

section PERLemata

  variable {X Y Z : ùíû} {œÅX : PER (P := P) X} {œÅY : PER (P := P) Y} {œÅZ : PER (P := P) Z}
  open ChosenFiniteProducts
  open Tripos.TermLE

  omit fp ccc in
  lemma isTop_iff_forall_isTop (f : X ‚ü∂ Y) {t : P‚ÇÄ X} : isTop t ‚Üî isTop (T.ùî∏ f t) := by
    constructor
    ¬∑ simp
      rintro rfl
      exact T.ùî∏_top_eq_top
    ¬∑ rintro H
      apply isTop_le_isTop H
      exact forall_le (ùî∏ := T.ùî∏ f)

  omit ccc in
  theorem PER.rel_le_extent_left : x : X, x' : X ‚ä¢ x = x ‚äì x = x' ‚áî ‚ü™.Œπ œÅX.rel | ‚ü®x, x'‚ü©‚ü´ := by
    apply conj_eq_top_iff.mpr
    constructor
    ¬∑ apply impl_eq_top_iff.mpr
      apply conj_le_right
    ¬∑ apply impl_eq_top_iff.mpr
      simp_proj
      apply le_conj
      ¬∑ have H := map_monotone (f := x : X, y : X ‚ä¢‚Çë ‚ü®‚ü®x, y‚ü©, x‚ü©) (impl_eq_top_iff.mp œÅX.trans)
        simp [comp_lift, lift_fst, lift_snd, lift_diag, lift_snd_fst, lift_fst_snd, lift_comp_fst_comp_snd, ‚ÜêCategory.assoc, Category.id_comp, Category.comp_id, ‚Üêmap_comp_app, map_conj, map_disj, map_impl] at H
        apply le_trans'
        ¬∑ exact H
        ¬∑ apply le_conj
          ¬∑ rfl
          ¬∑ have K := impl_eq_top_iff.mp œÅX.sym
            simp only [Category.comp_id, lift_fst_snd, map_id, lift_snd_fst] at K
            exact K
      ¬∑ rfl

  omit ccc in
  theorem PER.rel_le_extent_right : x : X, x' : X ‚ä¢ x = x' ‚äì x' = x' ‚áî ‚ü™.Œπ œÅX.rel | ‚ü®x, x'‚ü©‚ü´ := by
    apply conj_eq_top_iff.mpr
    constructor
    ¬∑ apply impl_eq_top_iff.mpr
      apply conj_le_left
    ¬∑ apply impl_eq_top_iff.mpr
      simp_proj
      apply le_conj
      ¬∑ rfl
      ¬∑ have H := map_monotone (f := x : X, y : X ‚ä¢‚Çë ‚ü®‚ü®y, x‚ü©, y‚ü©) (impl_eq_top_iff.mp œÅX.trans)
        simp [comp_lift, lift_fst, lift_snd, lift_diag, lift_fst_snd, lift_comp_fst_comp_snd, ‚ÜêCategory.assoc, Category.id_comp, Category.comp_id, ‚Üêmap_comp_app, map_conj, map_disj, map_impl] at H
        apply le_trans'
        ¬∑ exact H
        ¬∑ apply le_conj
          ¬∑ have K := impl_eq_top_iff.mp œÅX.sym
            simp only [Category.comp_id, lift_fst_snd, map_id] at K
            exact K
          ¬∑ rfl

  omit ccc in
  theorem exists_use' (œÜ : Formula (T := T) X) : x : X ‚ä¢ ‚ü™œÜ | x‚ü´ ‚áí ‚àÉ x' : X , ‚ü™œÜ | x'‚ü´ := by
    apply impl_eq_top_iff.mpr
    simp
    have isPB : IsPullback (fp.fst X X) (fp.snd _ _) (fp.toUnit _) (fp.toUnit _) := by
      have H := IsPullback.of_is_product' (P := X ‚äó X) (¬´fst¬ª := fp.fst _ _) (¬´snd¬ª := fp.snd _ _) (Z := ùüô_ ùíû)
        {
          lift := by
            rintro s
            simp
            have app := s.œÄ.app
            apply lift
            ¬∑ have H := app (Discrete.mk Limits.WalkingPair.left)
              simp at H
              exact H
            ¬∑ have H := app (Discrete.mk Limits.WalkingPair.right)
              simp at H
              exact H
          fac := by
            rintro s j
            induction j
            rename_i j
            induction j
            all_goals unfold Limits.BinaryFan.mk
            all_goals simp
          uniq := by
            simp
            rintro s m app
            have H‚ÇÄ := app (Discrete.mk Limits.WalkingPair.left)
            have H‚ÇÅ := app (Discrete.mk Limits.WalkingPair.right)
            simp at H‚ÇÄ
            simp at H‚ÇÅ
            rw [‚ÜêH‚ÇÄ, ‚ÜêH‚ÇÅ]
            simp_proj
        }
        (by exact Limits.IsTerminal.ofUnique (ùüô_ ùíû))
      simp [Limits.IsTerminal.from, Limits.IsTerminal.ofUnique, default] at H
      exact H
    rw [Any.BeckChevalley isPB]
    apply Any.adj.mpr
    rfl

  omit ccc in
  theorem exists_use (œÜ : Formula (T := T) X) : œÜ ‚â§ Formula.any (fp.fst _ _) (œÜ.app (fp.snd _ _)) := by
    have H := impl_eq_top_iff.mp (exists_use' œÜ)
    simp at H
    exact H

  -- omit ccc in
  -- theorem PER.extent_le_exists_rel : x : X ‚ä¢ ‚ü™.Œπ œÅX.rel | ‚ü®x, x‚ü©‚ü´ ‚áí ‚àÉ x' : X , x = x' := --($(lift (ùüô X) (fp.fst (X ‚äó X) X)) (œÅX.rel)) := by
  -- theorem PER.extent_le_exists_rel (x : ùüô_ ùíû ‚ü∂ X) : (Formula.Œπ œÅX.rel).app (x ‚â´ diag) ‚á® Formula.any (toUnit X) ((Formula.Œπ œÅX.rel).app (lift (toUnit _ ‚â´ x) (ùüô _))) = ‚ä§ := by
  -- theorem PER.extent_le_exists_rel' (x : ùüô_ ùíû ‚ü∂ X) : (Formula.Œπ œÅX.rel).app (x ‚â´ diag) ‚á® (Formula.any (fp.fst _ _) (Formula.Œπ œÅX.rel)).app (x) = ‚ä§ := by
  --   apply impl_eq_top_iff.mpr
  --   simp_proj
  --   trans
  --   ¬∑ exact exists_use (T := T) ((Formula.Œπ œÅX.rel).app (x ‚â´ diag))
  --   ¬∑ apply Any.adj.mpr
  --     simp [Any.comp_app]
  --     simp_proj
  --     rw [map_comp_app]
  --     have isPB : IsPullback (fp.fst (ùüô_ _) (ùüô_ _) ‚â´ x) (fp.snd _ _ ‚â´ x) (lift (toUnit X ‚â´ x) (ùüô _)) (lift (ùüô _) (toUnit X ‚â´ x)) := by sorry
  --     rw [Any.BeckChevalley isPB]
  --     simp_proj
  --     replace isPB : IsPullback (lift (ùüô _) (toUnit X ‚â´ x)) (diag) (fp.snd _ _) (fp.fst _ _) := by sorry
  --     rw [Any.BeckChevalley isPB]
  --     simp_proj

  -- omit ccc in
  -- theorem PER.extent_le_exists_rel'' (x : ùüô_ ùíû ‚ü∂ X) : (((Formula.Œπ œÅX.rel).app diag).impl (Formula.any (fp.fst _ _) (Formula.Œπ œÅX.rel))).app (x) = ‚ä§ := by
  --   rw [map_impl, ‚Üêmap_comp_app]
  --   exact œÅX.extent_le_exists_rel' x

  omit ccc in
  theorem PER.extent_le_exists_rel : (((Formula.Œπ œÅX.rel).app diag).impl (Formula.any (fp.fst _ _) (Formula.Œπ œÅX.rel))) = ‚ä§ := by
    apply impl_eq_top_iff.mpr
    apply All.adj.mpr
    apply le_trans
    ¬∑ exact Any.unit (f := fp.fst X X)
    apply le_trans
    ¬∑ exact All.unit (f := diag)
    ¬∑ simp_proj

  omit ccc
  @[ext]
  theorem PERHom_ext (f g : PERHom (T := T) œÅX œÅY) : f.hom = g.hom ‚Üí f = g := by
    induction f
    induction g
    rintro H
    unfold PERHom.hom at H; simp at H
    simp [H]

  omit ccc in
  theorem PERHom.map_le_extent_dom (f : PERHom (T := T) œÅX œÅY)
    : x : X, y : Y ‚ä¢ f‚∏®x‚∏© = y ‚áí x = x := by
    apply (All.eq_top_iff_forall_eq_top (x : X, y : Y ‚ä¢‚Çë x)).mpr
    simp_proj
    rw [map_comp_app (P := P)]
    conv => lhs; exact frobenius
    have cow := f.total_mpr
    simp at cow
    exact cow

  omit ccc in
  theorem PERHom.map_le_extent_cod (f: PERHom (T := T) œÅX œÅY)
    : x : X, y : Y ‚ä¢ f‚∏®x‚∏© = y ‚áí y = y := by
    apply weakening (x : X, y : Y ‚ä¢‚Çë ‚ü®‚ü®x, y‚ü©, y‚ü©) f.uniqueTerm
    unfold uniqueTerm
    simp_proj
    rw [conj_idem]
    apply f.unique

  -- omit ccc in theorem PERHom.rel_le_dom (f: PERHom (T := T) œÅX œÅY)
  --   : x : X, y : Y ‚ä¢ f‚∏®x‚∏© = y ‚áî x = x ‚äì f‚∏®x‚∏© = y := by
  --   have := f.map_le_extent_dom
  --   simp at this
  --   simp
  --   repeat rw [impl_conj_distrib, impl_self]
  --   rw [this]
  --   simp [conj_top_eq, top_conj_eq]
  --   unfold_quotient
  --   full_eval

  def PERHomComp (g : PERHom œÅY œÅZ) (f : PERHom œÅX œÅY) : PERHom œÅX œÅZ where
    hom := (x : X, z : Z ‚ä¢‚Çï ‚àÉ y : Y, (f‚∏®x‚∏© = y ‚äì g‚∏®y‚∏© = z)).eval
    congrDom := by
      simp [iota_eval]
      simp_proj
      have isPB : IsPullback
        (x : X, x' : X, z : Z, y : Y ‚ä¢‚Çë ‚ü®‚ü®x, x'‚ü©, z‚ü©) (x : X, x' : X, z : Z, y : Y ‚ä¢‚Çë ‚ü®‚ü®x', z‚ü©, y‚ü©)
        (x : X, x' : X, z : Z ‚ä¢‚Çë ‚ü®x', z‚ü©) (x' : X, z : Z, y : Y ‚ä¢‚Çë ‚ü®x', z‚ü©) := by sorry
      have isPB' : IsPullback
        (x : X, x' : X, z : Z, y : Y ‚ä¢‚Çë ‚ü®‚ü®x, x'‚ü©, z‚ü©) (x : X, x' : X, z : Z, y : Y ‚ä¢‚Çë ‚ü®‚ü®x, z‚ü©, y‚ü©)
        (x : X, x' : X, z : Z ‚ä¢‚Çë ‚ü®x, z‚ü©) (x : X, z : Z, y : Y ‚ä¢‚Çë ‚ü®x, z‚ü©) := by sorry

      simp [comp_lift, lift_fst, lift_snd, lift_diag, lift_snd_fst, lift_fst_snd, lift_comp_fst_comp_snd, ‚ÜêCategory.assoc, Category.id_comp, Category.comp_id, ‚Üêmap_comp_app, map_conj, map_disj, map_impl] at isPB
      rw [‚ÜêAny.BeckChevalley isPB]
      simp [comp_lift, lift_fst, lift_snd, lift_diag, lift_snd_fst, lift_fst_snd, lift_comp_fst_comp_snd, ‚ÜêCategory.assoc, Category.id_comp, Category.comp_id, ‚Üêmap_comp_app, map_conj, map_disj, map_impl] at isPB'
      rw [‚ÜêAny.BeckChevalley isPB']
      simp_proj
      rw [‚ÜêAny.frob_right, ‚Üêconj_assoc]
      simp_proj
      have cow := f.congrDom
      simp [comp_lift, lift_fst, lift_snd, lift_diag, lift_snd_fst, lift_fst_snd, lift_comp_fst_comp_snd, ‚ÜêCategory.assoc, Category.id_comp, Category.comp_id, ‚Üêmap_comp_app, map_conj, map_disj, map_impl] at cow
      replace cow := impl_eq_top_iff.mp cow
      conv =>
        enter [1, 1, 2, 1]
        conv =>
          lhs
          tactic =>
            have : (fp.fst ((X ‚äó X) ‚äó Z) Y) ‚â´ (fp.fst _ _) = (lift (fp.fst ((X ‚äó X) ‚äó Z) Y ‚â´ fp.fst _ _) (fp.snd _ _)) ‚â´ (fp.fst _ _) := by aesop_cat
            rw [this, map_comp_app]
        conv =>
          rhs
          tactic =>
            have : lift (((fp.fst ((X ‚äó X) ‚äó Z) Y) ‚â´ (fp.fst _ _)) ‚â´ (fp.snd _ _)) (fp.snd _ _) = (lift (fp.fst ((X ‚äó X) ‚äó Z) Y ‚â´ fp.fst _ _) (fp.snd _ _)) ‚â´ lift (fp.fst _ _ ‚â´ fp.snd _ _) (fp.snd _ _) := by aesop_cat
            rw [this, map_comp_app]
        rw [‚Üêmap_conj]
      apply impl_eq_top_iff.mpr
      apply le_trans
      ¬∑ apply Any.monotone
        apply conj_le_conj_right
        apply map_monotone
        exact cow
      ¬∑ simp_proj

    congrCod := by
      simp [iota_eval]
      simp_proj

      have isPB : IsPullback
        (x : X, z : Z, z' : Z, y : Y ‚ä¢‚Çë ‚ü®‚ü®x, z‚ü©, z'‚ü©) (x : X, z : Z, z' : Z, y : Y ‚ä¢‚Çë ‚ü®‚ü®x, z‚ü©, y‚ü©)
        (x : X, z : Z, z' : Z ‚ä¢‚Çë ‚ü®x, z‚ü©) (x : X, z : Z, y : Y ‚ä¢‚Çë ‚ü®x, z‚ü©) := by sorry
      have isPB' : IsPullback
        (x : X, z : Z, z' : Z, y : Y ‚ä¢‚Çë ‚ü®‚ü®x, z‚ü©, z'‚ü©) (x : X, z : Z, z' : Z, y : Y ‚ä¢‚Çë ‚ü®‚ü®x, z'‚ü©, y‚ü©)
        (x : X, z : Z, z' : Z ‚ä¢‚Çë ‚ü®x, z'‚ü©) (x : X, z' : Z, y : Y ‚ä¢‚Çë ‚ü®x, z'‚ü©) := by sorry

      simp [comp_lift, lift_fst, lift_snd, lift_diag, lift_snd_fst, lift_fst_snd, lift_comp_fst_comp_snd, ‚ÜêCategory.assoc, Category.id_comp, Category.comp_id, ‚Üêmap_comp_app, map_conj, map_disj, map_impl] at isPB
      rw [‚ÜêAny.BeckChevalley isPB]
      simp [comp_lift, lift_fst, lift_snd, lift_diag, lift_snd_fst, lift_fst_snd, lift_comp_fst_comp_snd, ‚ÜêCategory.assoc, Category.id_comp, Category.comp_id, ‚Üêmap_comp_app, map_conj, map_disj, map_impl] at isPB'
      rw [‚ÜêAny.BeckChevalley isPB']

      have H := impl_eq_top_iff.mp g.congrCod
      apply impl_eq_top_iff.mpr
      simp [comp_lift, lift_fst, lift_snd, lift_diag, lift_snd_fst, lift_fst_snd, lift_comp_fst_comp_snd, ‚ÜêCategory.assoc, Category.id_comp, Category.comp_id, ‚Üêmap_comp_app, map_conj, map_disj, map_impl] at H

      rw [‚ÜêAny.frob_left]
      simp_proj
      conv => enter [1, 2]; exact conj_assoc (P := P) _ _ _
      conv =>
        enter [1, 2, 2, 1]
        tactic =>
          have : lift (fp.snd ((X ‚äó Z) ‚äó Z) Y) ((fp.fst _ _ ‚â´ fp.fst _ _) ‚â´ fp.snd _ _) = (x : X, z : Z, z' : Z, y : Y ‚ä¢‚Çë ‚ü®‚ü®y, z‚ü©, z'‚ü©) ‚â´ fp.fst (Y ‚äó Z) Z := by aesop_cat
          rw [this, map_comp_app]
      conv =>
        enter [1, 2, 2, 2]
        tactic =>
          have : lift ((fp.fst ((X ‚äó Z) ‚äó Z) Y ‚â´ fp.fst _ _) ‚â´ fp.snd _ _) (fp.fst _ _ ‚â´ fp.snd _ _) = (x : X, z : Z, z' : Z, y : Y ‚ä¢‚Çë ‚ü®‚ü®y, z‚ü©, z'‚ü©) ‚â´ lift (fp.fst (Y ‚äó Z) Z ‚â´ fp.snd _ _) (fp.snd _ _) := by aesop_cat
          rw [this, map_comp_app]
      rw [‚Üêmap_conj]
      apply le_trans
      ¬∑ apply Any.monotone
        apply conj_le_conj_left
        apply map_monotone
        exact H
      ¬∑ simp_proj

    unique := by
      simp [iota_eval]
      simp_proj
      apply impl_eq_top_iff.mpr

      have isPB : IsPullback
        (x : X, z : Z, z' : Z, y : Y ‚ä¢‚Çë ‚ü®‚ü®x, z‚ü©, z'‚ü©) (x : X, z : Z, z' : Z, y : Y ‚ä¢‚Çë ‚ü®‚ü®x, z‚ü©, y‚ü©)
        (x : X, z : Z, z' : Z ‚ä¢‚Çë ‚ü®x, z‚ü©) (x : X, z : Z, y : Y ‚ä¢‚Çë ‚ü®x, z‚ü©) := by sorry

      simp [comp_lift, lift_fst, lift_snd, lift_diag, lift_snd_fst, lift_fst_snd, lift_comp_fst_comp_snd, ‚ÜêCategory.assoc, Category.id_comp, Category.comp_id, ‚Üêmap_comp_app, map_conj, map_disj, map_impl] at isPB
      rw [‚ÜêAny.BeckChevalley isPB, ‚ÜêAny.frob_left]
      simp_proj

      have isPB' : IsPullback
        (x : X, z : Z, z' : Z, y : Y, y' : Y ‚ä¢‚Çë ‚ü®‚ü®‚ü®x, z‚ü©, z'‚ü©, y‚ü©) (x : X, z : Z, z' : Z, y : Y, y' : Y ‚ä¢‚Çë ‚ü®‚ü®x, z'‚ü©, y'‚ü©)
        (x : X, z : Z, z' : Z, y : Y ‚ä¢‚Çë ‚ü®x, z'‚ü©) (x : X, z' : Z, y' : Y ‚ä¢‚Çë ‚ü®x, z'‚ü©) := by sorry

      simp [comp_lift, lift_fst, lift_snd, lift_diag, lift_snd_fst, lift_fst_snd, lift_comp_fst_comp_snd, ‚ÜêCategory.assoc, Category.id_comp, Category.comp_id, ‚Üêmap_comp_app, map_conj, map_disj, map_impl] at isPB'
      rw [‚ÜêAny.BeckChevalley isPB', ‚ÜêAny.frob_right]
      simp_proj

      have guniq := impl_eq_top_iff.mp g.unique
      have funiq := impl_eq_top_iff.mp f.unique
      have gcongrdom := impl_eq_top_iff.mp g.congrDom
      simp [comp_lift, lift_fst, lift_snd, lift_diag, lift_snd_fst, lift_fst_snd, lift_comp_fst_comp_snd, ‚ÜêCategory.assoc, Category.id_comp, Category.comp_id, ‚Üêmap_comp_app, map_conj, map_disj, map_impl] at guniq
      simp [comp_lift, lift_fst, lift_snd, lift_diag, lift_snd_fst, lift_fst_snd, lift_comp_fst_comp_snd, ‚ÜêCategory.assoc, Category.id_comp, Category.comp_id, ‚Üêmap_comp_app, map_conj, map_disj, map_impl] at funiq
      simp [comp_lift, lift_fst, lift_snd, lift_diag, lift_snd_fst, lift_fst_snd, lift_comp_fst_comp_snd, ‚ÜêCategory.assoc, Category.id_comp, Category.comp_id, ‚Üêmap_comp_app, map_conj, map_disj, map_impl] at gcongrdom

      conv => enter [1, 2, 2, 1]; rw [conj_comm]
      simp [conj_assoc]
      conv => enter [1, 2, 2, 2]; rw [‚Üêconj_assoc]
      simp_proj
      conv =>
        enter [1, 2, 2]
        conv =>
          enter [2, 1, 1]
          tactic =>
            have : lift (((fp.fst (((X ‚äó Z) ‚äó Z) ‚äó Y) Y ‚â´ fp.fst _ _) ‚â´ fp.fst _ _) ‚â´ fp.fst _ _) (fp.fst _ _ ‚â´ fp.snd _ _) = (x : X, z : Z, z' : Z, y : Y, y' : Y ‚ä¢‚Çë ‚ü®‚ü®x, y‚ü©, y'‚ü©) ‚â´ fp.fst (X ‚äó Y) Y := by aesop_cat
            rw [this, map_comp_app]
        conv =>
          enter [2, 1, 2]
          tactic =>
            have : lift (((fp.fst (((X ‚äó Z) ‚äó Z) ‚äó Y) Y ‚â´ fp.fst _ _) ‚â´ fp.fst _ _) ‚â´ fp.fst _ _) (fp.snd _ _) = (x : X, z : Z, z' : Z, y : Y, y' : Y ‚ä¢‚Çë ‚ü®‚ü®x, y‚ü©, y'‚ü©) ‚â´ (lift (fp.fst _ _ ‚â´ fp.fst _ _) (fp.snd _ _)) := by aesop_cat
            rw [this, map_comp_app]
        rw [‚Üêmap_conj]
      apply le_trans
      ¬∑ repeat apply Any.monotone
        apply conj_le_conj_left
        apply conj_le_conj_right
        apply map_monotone
        exact funiq
      simp_proj
      conv =>
        enter [1, 2, 2, 2]
        conv =>
          lhs
          tactic =>
            have : lift ((fp.fst (((X ‚äó Z) ‚äó Z) ‚äó Y) Y) ‚â´ fp.snd _ _) (fp.snd _ _) = x : X, z : Z, z' : Z, y : Y, y' : Y ‚ä¢‚Çë ‚ü®‚ü®y, y'‚ü©, z'‚ü© ‚â´ fp.fst _ _ := by aesop_cat
            rw [this, map_comp_app]
        conv =>
          rhs
          tactic =>
            have : lift (fp.snd (((X ‚äó Z) ‚äó Z) ‚äó Y) Y) ((fp.fst _ _ ‚â´ fp.fst _ _) ‚â´ fp.snd _ _) = x : X, z : Z, z' : Z, y : Y, y' : Y ‚ä¢‚Çë ‚ü®‚ü®y, y'‚ü©, z'‚ü© ‚â´ (lift (fp.fst _ _ ‚â´ fp.snd _ _) (fp.snd _ _)):= by aesop_cat
            rw [this, map_comp_app]
        exact (Eq.comm.mp map_conj)
      apply le_trans
      ¬∑ repeat apply Any.monotone
        apply conj_le_conj_left
        apply map_monotone
        exact gcongrdom
      simp_proj
      conv =>
        enter [1, 2, 2]
        conv =>
          lhs
          tactic =>
            have : lift ((fp.fst (((X ‚äó Z) ‚äó Z) ‚äó Y) Y) ‚â´ fp.snd _ _) (((fp.fst _ _ ‚â´ fp.fst _ _) ‚â´ fp.fst _ _) ‚â´ fp.snd _ _) = x : X, z : Z, z' : Z, y : Y, y' : Y ‚ä¢‚Çë ‚ü®‚ü®y, z‚ü©, z'‚ü© ‚â´ fp.fst _ _ := by aesop_cat
            rw [this, map_comp_app]
        conv =>
          rhs
          tactic =>
            have : lift ((fp.fst (((X ‚äó Z) ‚äó Z) ‚äó Y) Y) ‚â´ fp.snd _ _) ((fp.fst _ _ ‚â´ fp.fst _ _) ‚â´ fp.snd _ _) = x : X, z : Z, z' : Z, y : Y, y' : Y ‚ä¢‚Çë ‚ü®‚ü®y, z‚ü©, z'‚ü© ‚â´ (lift (fp.fst _ _ ‚â´ fp.fst _ _) (fp.snd _ _)) := by aesop_cat
            rw [this, map_comp_app]
        rw [‚Üêmap_conj]
      apply le_trans
      ¬∑ repeat apply Any.monotone
        apply map_monotone
        exact guniq
      ¬∑ repeat apply Any.adj.mp
        simp_proj

    total := by
      simp [iota_eval]
      simp_proj
      apply biimpl_eq_top_iff.mpr

      have ftot := le_antisymm (impl_eq_top_iff.mp f.total_mp) (impl_eq_top_iff.mp f.total_mpr)
      have gtot := le_antisymm (impl_eq_top_iff.mp g.total_mp) (impl_eq_top_iff.mp g.total_mpr)
      simp [comp_lift, lift_fst, lift_snd, lift_diag, lift_snd_fst, lift_fst_snd, lift_comp_fst_comp_snd, ‚ÜêCategory.assoc, Category.id_comp, Category.comp_id, ‚Üêmap_comp_app, map_conj, map_disj, map_impl] at ftot
      simp [comp_lift, lift_fst, lift_snd, lift_diag, lift_snd_fst, lift_fst_snd, lift_comp_fst_comp_snd, ‚ÜêCategory.assoc, Category.id_comp, Category.comp_id, ‚Üêmap_comp_app, map_conj, map_disj, map_impl] at gtot

      rw [Any.comm_app]
      simp_proj
      rw [Any.frob_right]

      have isPB : IsPullback
        (fp.fst (X ‚äó Y) Z) (lift (fp.fst _ _ ‚â´ fp.snd _ _) (fp.snd _ _))
        (fp.snd _ _) (fp.fst _ _) := by sorry
      rw [Any.BeckChevalley isPB, ‚Üêgtot]
      simp_proj

      have H := impl_eq_top_iff.mp f.map_le_extent_cod
      simp [comp_lift, lift_fst, lift_snd, lift_diag, lift_snd_fst, lift_fst_snd, lift_comp_fst_comp_snd, ‚ÜêCategory.assoc, Category.id_comp, Category.comp_id, ‚Üêmap_comp_app, map_conj, map_disj, map_impl] at H
      conv =>
        enter [2, 2]
        exact inf_eq_left.mpr H
      exact ftot
